
--#SET TERMINATOR @

CREATE TRIGGER TRIG000
  VERSION V1
  AFTER INSERT ON T1
  REFERENCING
    OLD ROW AS OLD_ROW
    NEW ROW AS NEW_ROW
    OLD_TABLE AS OLD_T
    NEW_TABLE AS NEW_T
  FOR EACH STATEMENT
  DISALLOW DEBUG MODE
  ALLOW DEBUG MODE
  DISABLE DEBUG MODE
  QUALIFIER SOMESCHEMANAME
  ASUTIME NO LIMIT
  ASUTIME LIMIT 42
  WLM ENVIRONMENT FOR DEBUG MODE TEST0001
  CURRENT DATA NO
  CURRENT DATA YES
  CONCURRENT ACCESS RESOLUTION USE CURRENTLY COMMITTED
  CONCURRENT ACCESS RESOLUTION WAIT FOR OUTCOME
  DYNAMICRULES RUN
  DYNAMICRULES BIND
  APPLICATION ENCODING SCHEME ASCII
  APPLICATION ENCODING SCHEME EBCDIC
  APPLICATION ENCODING SCHEME UNICODE
  WITHOUT EXPLAIN
  WITH EXPLAIN
  WITHOUT IMMEDIATE WRITE
  WITH IMMEDIATE WRITE
  ISOLATION LEVEL CS
  ISOLATION LEVEL RS
  ISOLATION LEVEL RR
  ISOLATION LEVEL UR
  OPTHINT ''
  OPTHINT 'Pretty much anything goes'
  SQL PATH SOMESCHEMANAME, SYSTEM PATH, SESSION USER, USER
  RELEASE AT COMMIT
  RELEASE AT DEALLOCATE
  ROUNDING DEC_ROUND_CEILING
  ROUNDING DEC_ROUND_DOWN
  ROUNDING DEC_ROUND_FLOOR
  ROUNDING DEC_ROUND_HALF_DOWN
  ROUNDING DEC_ROUND_HALF_EVEN
  ROUNDING DEC_ROUND_HALF_UP
  ROUNDING DEC_ROUND_UP
  DATE FORMAT ISO
  DATE FORMAT EUR
  DATE FORMAT USA
  DATE FORMAT JIS
  DATE FORMAT LOCAL
  DECIMAL(15)
  DECIMAL(31)
  DECIMAL(15,0)
  DECIMAL(31,0)
  TIME FORMAT ISO
  TIME FORMAT EUR
  TIME FORMAT USA
  TIME FORMAT JIS
  TIME FORMAT LOCAL
  FOR UPDATE CLAUSE REQUIRED
  FOR UPDATE CLAUSE OPTIONAL
  NOT SECURED
  SECURED
  BUSINESS_TIME SENSITIVE YES
  BUSINESS_TIME SENSITIVE NO
  SYSTEM_TIME SENSITIVE YES
  SYSTEM_TIME SENSITIVE NO
  ARCHIVE SENSITIVE YES
  ARCHIVE SENSITIVE NO
  APPLCOMPAT V12R1M500
  CONCENTRATE STATEMENTS OFF
  CONCENTRATE STATEMENTS WITH LITERALS
  BEGIN UPDATE T1 SET C1 = C1 - 1; END  
@

CREATE TRIGGER TRIG001
  AFTER INSERT ON T1
  FOR EACH ROW
  BEGIN ATOMIC
    UPDATE T2 SET C1 = C1 - 1;
  END
@

CREATE TRIGGER TRIG002
  AFTER INSERT ON T1
  FOR EACH ROW
    UPDATE T2 SET C1 = C1 - 1;
@

CREATE TRIGGER TRIG003
  AFTER DELETE ON T1
  FOR EACH ROW
  BEGIN ATOMIC
    UPDATE T2 SET C1 = C1 - 1;
  END
@

CREATE TRIGGER TRIG004
  AFTER DELETE ON T1
  FOR EACH ROW
    UPDATE T2 SET C1 = C1 - 1;
@

CREATE TRIGGER TRIG005
  AFTER UPDATE OF C1, C2 ON T1
  REFERENCING NEW_TABLE AS NEW
  FOR EACH ROW
  WHEN (NEW.C1 < 0.10 * NEW.C2)
  BEGIN ATOMIC
    DECLARE V1 INTEGER;
    VALUES(SOME_FUNCTION(NEW.C2 - NEW.C1, NEW.C3))
      INTO V1;
    UPDATE T2 SET C2 = V1 WHERE C1 = NEW.C3;
  END
@

CREATE TRIGGER TRIG006
  AFTER DELETE ON T1
  FOR EACH ROW
  BEGIN ATOMIC
    DECLARE V1 INTEGER;
    SET V1 = C1 - 1;
    IF C1 > 0 THEN
      UPDATE T2 SET C1 = V1;
    ELSE
      UPDATE T2 SET C1 = 0;
    END IF
  END
@

CREATE TRIGGER TRIG007
  AFTER UPDATE ON T1
  REFERENCING NEW_TABLE AS NEW
  FOR EACH STATEMENT
  P1: BEGIN ATOMIC
    DECLARE V1 INTEGER;
    SELECT C1
      INTO V1
      FROM NEW
      WHERE C1 < 0.10 * C2;
    IF V1 > 100 THEN
      SIGNAL '77777' SET MESSAGE_TEXT = 'Bad craziness';
    END IF
  END P1
@

CREATE TRIGGER TRIG008
  AFTER UPDATE ON T1
  REFERENCING
    OLD AS OLD_T1
    NEW AS NEW_T1
  FOR EACH ROW
  WHEN (NEW_T1.C1 > (OLD_T1.C1 * 1.2))
    BEGIN ATOMIC
      SIGNAL SQLSTATE '31415' ('Oh, oh no.  Just no.');
    END
@

CREATE TRIGGER TRIG009 INSTEAD OF INSERT ON T1
  REFERENCING NEW AS NEW
  FOR EACH ROW
    BEGIN ATOMIC
      INSERT
        INTO T2
        VALUES
          (
            C1
          , (5/9) * C2 + 459.67
          )
     END;
@

CREATE TRIGGER TRIG010
  NO CASCADE BEFORE UPDATE OF C1 ON T1
  REFERENCING
    NEW AS NEW
    OLD AS OLD
  FOR EACH ROW
    BEGIN ATOMIC
      SET NEW.C2 =
        CASE
          WHEN NEW.C1 > 
            (SELECT MAX(C1) FROM T2
             WHERE C3 = NEW.C3 AND YEAR(C4) = YEAR(CURRENT DATE))
          THEN 'A'
          WHEN NEW.C1 <
            (SELECT MIN(C1) FROM T2
             WHERE C3 = NEW.C3 AND YEAR(C4) = YEAR(CURRENT DATE))
          THEN 'B'
          WHEN NEW.C1 > OLD.C1 THEN 'C'
          WHEN NEW.C1 < OLD.C1 THEN 'D' 
          WHEN NEW.C1 = OLD.C1 THEN 'E'
        END; --note this is a case expression not a case statement
    END
@

CREATE OR REPLACE TRIGGER TRIG011
  BEFORE INSERT ON T1
  REFERENCING NEW AS NEW
  FOR EACH ROW
  WHEN (NEW.C1 IS NULL OR NEW.C1 > '20:30')
    P1: BEGIN
      IF (NEW.C1 IS NULL) THEN
        SET NEW.C1 = NEW.C2 + 1 HOUR;
      END IF;
      IF (NEW.C1 > '20:30') THEN
        SIGNAL SQLSTATE '27182'
          SET MESSAGE_TEXT = 'this is a bad time';
      END IF;
    END
@

CREATE OR REPLACE TRIGGER SCHEMA.TRIG012
  BEFORE INSERT ON T1
  REFERENCING NEW AS NEW
  FOR EACH ROW
  WHEN (NEW.C1 IS NULL OR NEW.C1 > '20:30')
    P1: BEGIN
      IF (NEW.C1 IS NULL) THEN
        SET NEW.C1 = NEW.C2 + 1 HOUR;
      END IF;
      IF (NEW.C1 > '20:30') THEN
        SIGNAL SQLSTATE '27182'
          SET MESSAGE_TEXT = 'this is a bad time';
      END IF;
    END
@


